name: Cleanup Feature Environment

on:
  delete:

env:
  AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
  MANAGED_IDENTITY: ${{ vars.MANAGED_IDENTITY }}

permissions:
  id-token: write
  contents: read

jobs:
  cleanup-feature-environment:
    name: Clean Up Feature Environment
    runs-on: ubuntu-latest
    # Only run for feature branch deletions
    if: >
      github.event_name == 'delete' && github.event.ref_type == 'branch' &&
      (startsWith(github.event.ref, 'feature-') || startsWith(github.event.ref, 'ex-'))
    
    steps:
    - name: Determine branch name and validate
      id: branch-info
      run: |
        # Extract branch name from delete event
        BRANCH_NAME="${{ github.event.ref }}"
        echo "Triggered by branch deletion: $BRANCH_NAME"
        echo "Deleted ref type: ${{ github.event.ref_type }}"
        
        # Sanitize branch name (remove feature- prefix, special characters)
        CLEAN_BRANCH=$(echo "$BRANCH_NAME" | sed 's|^feature-||' | tr '/' '-')
        NAMESPACE="feature-${CLEAN_BRANCH}"
        
        echo "Original branch: $BRANCH_NAME"
        echo "Sanitized branch: $CLEAN_BRANCH"
        echo "Target namespace: $NAMESPACE"
        
        # Export variables for subsequent steps
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        echo "CLEAN_BRANCH=$CLEAN_BRANCH" >> $GITHUB_ENV
        echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
        
        # Add to step summary
        echo "## Feature Environment Cleanup" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** \`$NAMESPACE\`" >> $GITHUB_STEP_SUMMARY
    
    - name: Safety validations
      run: |
        # Define protected namespaces that should never be deleted
        PROTECTED_NAMESPACES=("default" "kube-system" "azure-alb-system" "project" "kube-public" "kube-node-lease")
        
        echo "Performing safety validations..."
        echo "Target namespace: $NAMESPACE"
        echo "Protected namespaces: ${PROTECTED_NAMESPACES[*]}"
        
        # Check if target namespace is protected
        for protected in "${PROTECTED_NAMESPACES[@]}"; do
          if [ "$NAMESPACE" = "$protected" ]; then
            echo "âŒ ERROR: Cannot delete protected namespace: $NAMESPACE"
            echo "Protected namespaces: ${PROTECTED_NAMESPACES[*]}"
            exit 1
          fi
        done
        
        # Validate namespace naming pattern
        if [[ ! "$NAMESPACE" =~ ^feature-.+ ]]; then
          echo "âŒ ERROR: Invalid namespace pattern: $NAMESPACE"
          echo "Expected pattern: feature-*"
          exit 1
        fi
        
        echo "âœ… Safety validations passed"
        echo "- Namespace $NAMESPACE is not protected"
        echo "- Namespace follows expected naming pattern"
    
    - name: Azure Login via Workload Identity
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Connect to AKS cluster
      run: |
        echo "Connecting to AKS cluster..."
        az aks get-credentials \
          --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }}
        
        # Verify cluster connectivity
        kubectl cluster-info
        echo "Connected to AKS cluster"
    
    - name: Pre-cleanup resource inventory
      id: inventory
      run: |
        echo "Taking inventory of resources before cleanup..."
        
        # Check if namespace exists
        if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          echo "ðŸ“‹ Namespace $NAMESPACE exists - taking inventory:"
          
          # Count resources
          PODS=$(kubectl get pods -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          DEPLOYMENTS=$(kubectl get deployments -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          SERVICES=$(kubectl get services -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          PVCS=$(kubectl get pvc -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          CRONJOBS=$(kubectl get cronjobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          JOBS=$(kubectl get jobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          HTTPROUTES=$(kubectl get httproutes -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          
          echo "Resource counts (all will be deleted with namespace):"
          echo "- Pods: $PODS"
          echo "- Deployments: $DEPLOYMENTS"
          echo "- Services: $SERVICES"
          echo "- PVCs: $PVCS"
          echo "- CronJobs: $CRONJOBS"
          echo "- Jobs: $JOBS"
          echo "- HTTPRoutes: $HTTPROUTES"
          
          # Show detailed resources for debugging
          echo ""
          echo "Detailed resource list:"
          kubectl get all,pvc,secrets,httproutes -n "$NAMESPACE" || true
          
          # Set output for subsequent steps
          echo "namespace_exists=true" >> $GITHUB_OUTPUT
          
          # Add to step summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resources Found ðŸ“‹" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Type | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Pods | $PODS |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployments | $DEPLOYMENTS |" >> $GITHUB_STEP_SUMMARY
          echo "| Services | $SERVICES |" >> $GITHUB_STEP_SUMMARY
          echo "| PVCs | $PVCS |" >> $GITHUB_STEP_SUMMARY
          echo "| CronJobs | $CRONJOBS |" >> $GITHUB_STEP_SUMMARY
          echo "| Jobs | $JOBS |" >> $GITHUB_STEP_SUMMARY
          echo "| HTTPRoutes | $HTTPROUTES |" >> $GITHUB_STEP_SUMMARY
        else
          echo "Namespace $NAMESPACE does not exist"
          echo "namespace_exists=false" >> $GITHUB_OUTPUT
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resources Found ðŸ“‹" >> $GITHUB_STEP_SUMMARY
          echo "Namespace \`$NAMESPACE\` does not exist - skipping Kubernetes cleanup" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Emergency CronJob suspension
      if: steps.inventory.outputs.namespace_exists == 'true'
      run: |
        echo "CRITICAL: Suspending CronJobs to prevent runaway job creation during namespace deletion..."
        
        # Count CronJobs and Jobs for reporting
        CRONJOB_COUNT=$(kubectl get cronjobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
        JOB_COUNT=$(kubectl get jobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
        
        echo "Found $CRONJOB_COUNT CronJobs and $JOB_COUNT Jobs in namespace $NAMESPACE"
        
        if [ "$CRONJOB_COUNT" -gt 0 ]; then
          echo "Found CronJobs to suspend:"
          kubectl get cronjobs -n "$NAMESPACE" -o name || true
          
          # Suspend each CronJob to prevent new job creation during deletion
          kubectl get cronjobs -n "$NAMESPACE" -o name | while read -r cronjob; do
            if [ -n "$cronjob" ]; then
              echo "Suspending $cronjob..."
              kubectl patch "$cronjob" -n "$NAMESPACE" -p '{"spec":{"suspend":true}}' || {
                echo "Warning: Failed to suspend $cronjob, continuing..."
              }
            fi
          done
          
          # Wait a moment for suspension to take effect
          sleep 5
          echo "CronJob suspension completed"
        else
          echo "No CronJobs found in namespace $NAMESPACE"
        fi
        
        if [ "$JOB_COUNT" -gt 0 ]; then
          echo "Jobs found (showing status before namespace deletion):"
          kubectl get jobs -n "$NAMESPACE" -o wide || true
          
          # Show failed jobs count for monitoring
          FAILED_JOBS=$(kubectl get jobs -n "$NAMESPACE" --field-selector status.successful!=1 --no-headers 2>/dev/null | wc -l)
          if [ "$FAILED_JOBS" -gt 0 ]; then
            echo "Found $FAILED_JOBS failed jobs (will be cleaned up with namespace deletion)"
          fi
        fi
        
        echo "Emergency CronJob handling completed - namespace deletion will handle all cleanup"
    
    - name: Delete Kubernetes namespace
      if: steps.inventory.outputs.namespace_exists == 'true'
      run: |
        echo "Deleting namespace $NAMESPACE and all contained resources..."
        
        echo "Initiating namespace deletion..."
        kubectl delete namespace "$NAMESPACE" --timeout=300s || {
          echo "Warning: Namespace deletion timed out or failed, attempting force cleanup..."
          # Try to force delete if standard deletion fails
          kubectl delete namespace "$NAMESPACE" --grace-period=0 --force || {
            echo "Error: Unable to delete namespace $NAMESPACE"
            echo "Manual intervention may be required"
            # Don't exit here - continue with Azure cleanup
          }
        }
    
    - name: Verify Kubernetes cleanup
      if: steps.inventory.outputs.namespace_exists == 'true'
      run: |
        echo "ðŸ” Verifying namespace deletion..."
        
        # Wait for namespace to be fully deleted
        echo "Waiting for namespace deletion to complete..."
        kubectl wait --for=delete namespace/"$NAMESPACE" --timeout=120s || {
          echo "Warning: Namespace deletion verification timed out"
        }
        
        # Final verification
        if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          echo "WARNING: Namespace $NAMESPACE still exists after deletion attempt"
          echo "Checking remaining resources:"
          kubectl get all,pvc,secrets,httproutes -n "$NAMESPACE" || true
          echo "Manual cleanup may be required"
        else
          echo "Namespace $NAMESPACE successfully deleted"
        fi
    
    - name: Check and delete Azure federated credential
      run: |
        CREDENTIAL_NAME="postgres-workload-identity-${CLEAN_BRANCH}"
        
        echo "Checking Azure federated credential: $CREDENTIAL_NAME"
        
        # Check if credential exists
        if az identity federated-credential show \
            --identity-name ${{ env.MANAGED_IDENTITY }} \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
          
          echo "Found federated credential: $CREDENTIAL_NAME"
          echo "Deleting federated credential..."
          az identity federated-credential delete \
            --identity-name ${{ env.MANAGED_IDENTITY }} \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name "$CREDENTIAL_NAME" \
            --yes || {
            echo "Warning: Failed to delete federated credential $CREDENTIAL_NAME"
            echo "This may require manual cleanup"
            # Don't exit - this is not critical for basic functionality
          }
          
          # Verify deletion
          if az identity federated-credential show \
              --identity-name ${{ env.MANAGED_IDENTITY }} \
              --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
              --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
            echo "WARNING: Federated credential $CREDENTIAL_NAME still exists after deletion"
          else
            echo "Federated credential $CREDENTIAL_NAME successfully deleted"
          fi
        else
          echo "Federated credential $CREDENTIAL_NAME does not exist (already cleaned up or never created)"
        fi
    
    - name: Final verification and reporting
      run: |
        echo "Final verification and cleanup report..."
        
        # Initialize status variables
        K8S_STATUS="N/A"
        AZURE_STATUS="N/A"
        
        # Check Kubernetes cleanup status
        if [ "${{ steps.inventory.outputs.namespace_exists }}" != "true" ]; then
          K8S_STATUS="SKIPPED (namespace didn't exist)"
        elif kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          K8S_STATUS="FAILED (namespace still exists)"
        else
          K8S_STATUS="SUCCESS"
        fi
        
        # Check Azure cleanup status  
        CREDENTIAL_NAME="postgres-workload-identity-${CLEAN_BRANCH}"
        if az identity federated-credential show \
            --identity-name ${{ env.MANAGED_IDENTITY }} \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
          AZURE_STATUS="FAILED (credential still exists)"
        else
          AZURE_STATUS="SUCCESS"
        fi
        
        # Generate final report
        echo ""
        echo "## CLEANUP REPORT ##"
        echo "Branch: $BRANCH_NAME"
        echo "Namespace: $NAMESPACE"
        echo "Kubernetes cleanup: $K8S_STATUS"
        echo "Azure credential cleanup: $AZURE_STATUS"
        
        # Add to step summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Cleanup Results" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Kubernetes | $K8S_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Azure Credential | $AZURE_STATUS |" >> $GITHUB_STEP_SUMMARY
        
        # Determine exit status
        if [[ "$K8S_STATUS" == *"FAILED"* ]] || [[ "$AZURE_STATUS" == *"FAILED"* ]]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Some cleanup operations failed - manual intervention may be required**" >> $GITHUB_STEP_SUMMARY
          exit 1
        else
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All cleanup operations completed successfully**" >> $GITHUB_STEP_SUMMARY
          echo "Feature environment for branch \`$CLEAN_BRANCH\` has been fully deprovisioned"
        fi
    
    - name: List remaining federated credentials (for monitoring)
      if: always()
      run: |
        echo "Current federated credentials on managed identity (for monitoring):"
        az identity federated-credential list \
          --identity-name ${{ env.MANAGED_IDENTITY }} \
          --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
          --query "[].{name:name, subject:subject}" \
          --output table || {
          echo "Warning: Could not list federated credentials"
        }
