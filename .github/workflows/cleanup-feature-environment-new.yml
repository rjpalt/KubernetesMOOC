name: Cleanup Feature Environment

on:
  delete:
  workflow_dispatch:
    # Manual trigger for testing, emergency cleanup, and dry runs
    inputs:
      branch_name:
        description: 'Branch name to clean up (without feature- prefix if applicable)'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode (show what would be deleted)'
        required: false
        type: boolean
        default: false

permissions:
  id-token: write
  contents: read

env:
  RESOURCE_GROUP: 'kubernetes-learning'
  AKS_CLUSTER: 'kube-mooc'
  MANAGED_IDENTITY: 'keyvault-identity-kube-mooc'

jobs:
  cleanup-feature-environment:
    name: Clean Up Feature Environment
    runs-on: ubuntu-latest
    # Only run for feature branches when triggered by delete, or always for manual dispatch
    if: >
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'delete' && github.event.ref_type == 'branch' &&
       (startsWith(github.event.ref, 'feature-') || startsWith(github.event.ref, 'ex-')))
    
    steps:
    - name: Determine branch name and validate
      id: branch-info
      run: |
        # Extract branch name from different trigger contexts
        if [ "${{ github.event_name }}" = "delete" ]; then
          BRANCH_NAME="${{ github.event.ref }}"
          echo "Triggered by branch deletion: $BRANCH_NAME"
          echo "Deleted ref type: ${{ github.event.ref_type }}"
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          BRANCH_NAME="${{ github.event.inputs.branch_name }}"
          echo "Triggered manually for branch: $BRANCH_NAME"
        else
          echo "ERROR: Unsupported trigger event: ${{ github.event_name }}"
          exit 1
        fi
        
        # Sanitize branch name (remove prefixes, special characters)
        # For delete events, the ref is just the branch name (no refs/heads/ prefix)
        CLEAN_BRANCH=$(echo "$BRANCH_NAME" | sed 's|^feature-||' | tr '/' '-')
        NAMESPACE="feature-${CLEAN_BRANCH}"
        
        # Set dry run mode
        DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
        
        echo "Original branch: $BRANCH_NAME"
        echo "Sanitized branch: $CLEAN_BRANCH"
        echo "Target namespace: $NAMESPACE"
        echo "Dry run mode: $DRY_RUN"
        
        # Export variables for subsequent steps
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        echo "CLEAN_BRANCH=$CLEAN_BRANCH" >> $GITHUB_ENV
        echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
        echo "DRY_RUN=$DRY_RUN" >> $GITHUB_ENV
        
        # Add to step summary
        echo "## Feature Environment Cleanup ðŸ§¹" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** \`$NAMESPACE\`" >> $GITHUB_STEP_SUMMARY
        echo "**Mode:** $([ "$DRY_RUN" = "true" ] && echo "DRY RUN" || echo "LIVE CLEANUP")" >> $GITHUB_STEP_SUMMARY
    
    - name: Safety validations
      run: |
        # Define protected namespaces that should never be deleted
        PROTECTED_NAMESPACES=("default" "kube-system" "azure-alb-system" "project" "kube-public" "kube-node-lease")
        
        echo "Performing safety validations..."
        echo "Target namespace: $NAMESPACE"
        echo "Protected namespaces: ${PROTECTED_NAMESPACES[*]}"
        
        # Check if target namespace is protected
        for protected in "${PROTECTED_NAMESPACES[@]}"; do
          if [ "$NAMESPACE" = "$protected" ]; then
            echo "âŒ ERROR: Cannot delete protected namespace: $NAMESPACE"
            echo "Protected namespaces: ${PROTECTED_NAMESPACES[*]}"
            exit 1
          fi
        done
        
        # Validate namespace naming pattern
        if [[ ! "$NAMESPACE" =~ ^feature-.+ ]]; then
          echo "âŒ ERROR: Invalid namespace pattern: $NAMESPACE"
          echo "Expected pattern: feature-*"
          exit 1
        fi
        
        echo "âœ… Safety validations passed"
        echo "- Namespace $NAMESPACE is not protected"
        echo "- Namespace follows expected naming pattern"
    
    - name: Azure Login via Workload Identity
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Connect to AKS cluster
      run: |
        echo "Connecting to AKS cluster..."
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER }}
        
        # Verify cluster connectivity
        kubectl cluster-info
        echo "âœ… Connected to AKS cluster"
    
    - name: Pre-cleanup resource inventory
      id: inventory
      run: |
        echo "Taking inventory of resources before cleanup..."
        
        # Check if namespace exists
        if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          echo "ðŸ“‹ Namespace $NAMESPACE exists - taking inventory:"
          
          # Count resources
          PODS=$(kubectl get pods -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          DEPLOYMENTS=$(kubectl get deployments -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          SERVICES=$(kubectl get services -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          PVCS=$(kubectl get pvc -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          CRONJOBS=$(kubectl get cronjobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          JOBS=$(kubectl get jobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          HTTPROUTES=$(kubectl get httproutes -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
          
          echo "Resource counts (all will be deleted with namespace):"
          echo "- Pods: $PODS"
          echo "- Deployments: $DEPLOYMENTS"
          echo "- Services: $SERVICES"
          echo "- PVCs: $PVCS"
          echo "- CronJobs: $CRONJOBS"
          echo "- Jobs: $JOBS"
          echo "- HTTPRoutes: $HTTPROUTES"
          
          # Show detailed resources for debugging
          echo ""
          echo "Detailed resource list:"
          kubectl get all,pvc,secrets,httproutes -n "$NAMESPACE" || true
          
          # Set output for subsequent steps
          echo "namespace_exists=true" >> $GITHUB_OUTPUT
          
          # Add to step summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resources Found ðŸ“‹" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Type | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Pods | $PODS |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployments | $DEPLOYMENTS |" >> $GITHUB_STEP_SUMMARY
          echo "| Services | $SERVICES |" >> $GITHUB_STEP_SUMMARY
          echo "| PVCs | $PVCS |" >> $GITHUB_STEP_SUMMARY
          echo "| CronJobs | $CRONJOBS |" >> $GITHUB_STEP_SUMMARY
          echo "| Jobs | $JOBS |" >> $GITHUB_STEP_SUMMARY
          echo "| HTTPRoutes | $HTTPROUTES |" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸  Namespace $NAMESPACE does not exist"
          echo "namespace_exists=false" >> $GITHUB_OUTPUT
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resources Found ðŸ“‹" >> $GITHUB_STEP_SUMMARY
          echo "Namespace \`$NAMESPACE\` does not exist - skipping Kubernetes cleanup" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Emergency CronJob suspension
      if: steps.inventory.outputs.namespace_exists == 'true'
      run: |
        echo "ðŸš¨ CRITICAL: Suspending CronJobs to prevent runaway job creation during namespace deletion..."
        
        # Count CronJobs and Jobs for reporting
        CRONJOB_COUNT=$(kubectl get cronjobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
        JOB_COUNT=$(kubectl get jobs -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
        
        echo "Found $CRONJOB_COUNT CronJobs and $JOB_COUNT Jobs in namespace $NAMESPACE"
        
        if [ "$CRONJOB_COUNT" -gt 0 ]; then
          echo "Found CronJobs to suspend:"
          kubectl get cronjobs -n "$NAMESPACE" -o name || true
          
          # Suspend each CronJob to prevent new job creation during deletion
          kubectl get cronjobs -n "$NAMESPACE" -o name | while read -r cronjob; do
            if [ -n "$cronjob" ]; then
              echo "Suspending $cronjob..."
              if [ "$DRY_RUN" = "true" ]; then
                echo "DRY RUN: Would suspend $cronjob"
              else
                kubectl patch "$cronjob" -n "$NAMESPACE" -p '{"spec":{"suspend":true}}' || {
                  echo "Warning: Failed to suspend $cronjob, continuing..."
                }
              fi
            fi
          done
          
          # Wait a moment for suspension to take effect
          sleep 5
          echo "âœ… CronJob suspension completed"
        else
          echo "No CronJobs found in namespace $NAMESPACE"
        fi
        
        if [ "$JOB_COUNT" -gt 0 ]; then
          echo "Jobs found (showing status before namespace deletion):"
          kubectl get jobs -n "$NAMESPACE" -o wide || true
          
          # Show failed jobs count for monitoring
          FAILED_JOBS=$(kubectl get jobs -n "$NAMESPACE" --field-selector status.successful!=1 --no-headers 2>/dev/null | wc -l)
          if [ "$FAILED_JOBS" -gt 0 ]; then
            echo "âš ï¸  Found $FAILED_JOBS failed jobs (will be cleaned up with namespace deletion)"
          fi
        fi
        
        echo "âœ… Emergency CronJob handling completed - namespace deletion will handle all cleanup"
    
    - name: Delete Kubernetes namespace
      if: steps.inventory.outputs.namespace_exists == 'true'
      run: |
        echo "ðŸ—‘ï¸  Deleting namespace $NAMESPACE and all contained resources..."
        
        if [ "$DRY_RUN" = "true" ]; then
          echo "DRY RUN: Would delete namespace $NAMESPACE"
          echo "This would cascade delete all resources:"
          kubectl get all,pvc,secrets,httproutes -n "$NAMESPACE" || true
        else
          echo "Initiating namespace deletion..."
          kubectl delete namespace "$NAMESPACE" --timeout=300s || {
            echo "Warning: Namespace deletion timed out or failed, attempting force cleanup..."
            # Try to force delete if standard deletion fails
            kubectl delete namespace "$NAMESPACE" --grace-period=0 --force || {
              echo "Error: Unable to delete namespace $NAMESPACE"
              echo "Manual intervention may be required"
              # Don't exit here - continue with Azure cleanup
            }
          }
        fi
    
    - name: Verify Kubernetes cleanup
      if: steps.inventory.outputs.namespace_exists == 'true' && github.event.inputs.dry_run != 'true'
      run: |
        echo "ðŸ” Verifying namespace deletion..."
        
        # Wait for namespace to be fully deleted
        echo "Waiting for namespace deletion to complete..."
        kubectl wait --for=delete namespace/"$NAMESPACE" --timeout=120s || {
          echo "Warning: Namespace deletion verification timed out"
        }
        
        # Final verification
        if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          echo "âš ï¸  WARNING: Namespace $NAMESPACE still exists after deletion attempt"
          echo "Checking remaining resources:"
          kubectl get all,pvc,secrets,httproutes -n "$NAMESPACE" || true
          echo "Manual cleanup may be required"
        else
          echo "âœ… Namespace $NAMESPACE successfully deleted"
        fi
    
    - name: Check and delete Azure federated credential
      run: |
        CREDENTIAL_NAME="postgres-workload-identity-${CLEAN_BRANCH}"
        
        echo "ðŸ” Checking Azure federated credential: $CREDENTIAL_NAME"
        
        # Check if credential exists
        if az identity federated-credential show \
            --identity-name "$MANAGED_IDENTITY" \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
          
          echo "Found federated credential: $CREDENTIAL_NAME"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would delete federated credential $CREDENTIAL_NAME"
          else
            echo "Deleting federated credential..."
            az identity federated-credential delete \
              --identity-name "$MANAGED_IDENTITY" \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CREDENTIAL_NAME" \
              --yes || {
              echo "Warning: Failed to delete federated credential $CREDENTIAL_NAME"
              echo "This may require manual cleanup"
              # Don't exit - this is not critical for basic functionality
            }
            
            # Verify deletion
            if az identity federated-credential show \
                --identity-name "$MANAGED_IDENTITY" \
                --resource-group "$RESOURCE_GROUP" \
                --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
              echo "âš ï¸  WARNING: Federated credential $CREDENTIAL_NAME still exists after deletion"
            else
              echo "âœ… Federated credential $CREDENTIAL_NAME successfully deleted"
            fi
          fi
        else
          echo "Federated credential $CREDENTIAL_NAME does not exist (already cleaned up or never created)"
        fi
    
    - name: Final verification and reporting
      run: |
        echo "ðŸŽ¯ Final verification and cleanup report..."
        
        # Initialize status variables
        K8S_STATUS="N/A"
        AZURE_STATUS="N/A"
        
        # Check Kubernetes cleanup status
        if [ "${{ steps.inventory.outputs.namespace_exists }}" != "true" ]; then
          K8S_STATUS="SKIPPED (namespace didn't exist)"
        elif [ "$DRY_RUN" = "true" ]; then
          K8S_STATUS="DRY RUN (would have been deleted)"
        elif kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
          K8S_STATUS="âŒ FAILED (namespace still exists)"
        else
          K8S_STATUS="âœ… SUCCESS"
        fi
        
        # Check Azure cleanup status  
        CREDENTIAL_NAME="postgres-workload-identity-${CLEAN_BRANCH}"
        if [ "$DRY_RUN" = "true" ]; then
          AZURE_STATUS="DRY RUN (would have been deleted)"
        elif az identity federated-credential show \
            --identity-name "$MANAGED_IDENTITY" \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CREDENTIAL_NAME" >/dev/null 2>&1; then
          AZURE_STATUS="âŒ FAILED (credential still exists)"
        else
          AZURE_STATUS="âœ… SUCCESS"
        fi
        
        # Generate final report
        echo ""
        echo "## CLEANUP REPORT ##"
        echo "Branch: $BRANCH_NAME"
        echo "Namespace: $NAMESPACE"
        echo "Kubernetes cleanup: $K8S_STATUS"
        echo "Azure credential cleanup: $AZURE_STATUS"
        echo "Mode: $([ "$DRY_RUN" = "true" ] && echo "DRY RUN" || echo "LIVE CLEANUP")"
        
        # Add to step summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Cleanup Results ðŸ“Š" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Kubernetes | $K8S_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Azure Credential | $AZURE_STATUS |" >> $GITHUB_STEP_SUMMARY
        
        # Determine exit status
        if [[ "$K8S_STATUS" == *"FAILED"* ]] || [[ "$AZURE_STATUS" == *"FAILED"* ]]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Some cleanup operations failed - manual intervention may be required**" >> $GITHUB_STEP_SUMMARY
          exit 1
        else
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **All cleanup operations completed successfully**" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Feature environment for branch \`$CLEAN_BRANCH\` has been fully deprovisioned"
        fi
    
    - name: List remaining federated credentials (for monitoring)
      if: always()
      run: |
        echo "ðŸ“‹ Current federated credentials on managed identity (for monitoring):"
        az identity federated-credential list \
          --identity-name "$MANAGED_IDENTITY" \
          --resource-group "$RESOURCE_GROUP" \
          --query "[].{name:name, subject:subject}" \
          --output table || {
          echo "Warning: Could not list federated credentials"
        }
